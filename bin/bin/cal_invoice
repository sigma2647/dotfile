#!/usr/bin/env bash

# cal_invoice_fast：高性能修复版发票计算器
# 用法: ./cal_invoice_fast [目录1 目录2 ...]

TOTAL=0
COUNT=0

process_dir() {
    local dir="${1:-.}"
    echo "📁 $dir"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    local dir_total=0
    local dir_count=0
    local amounts=()

    # ⚠️ 用 process substitution 避免子 shell
    while IFS= read -r file; do
        name=$(basename "$file")
        if [[ $name =~ ^([0-9]+)_([0-9.]+)_ ]]; then
            num="${BASH_REMATCH[1]}"
            amount="${BASH_REMATCH[2]}"
            ext="${name##*.}"

            printf "%-4s │ ¥%-8s │ %-6s │ %s\n" "$num" "$amount" "$ext" "${name%.*}"

            amounts+=("$amount")
            ((dir_count++))
        fi
    done < <(find "$dir" -maxdepth 1 -type f -name '*_*_*' | sort -V)

    if (( dir_count > 0 )); then
        dir_total=$(printf "%s\n" "${amounts[@]}" | awk '{s+=$1} END {printf "%.2f", s}')

        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        printf "📊 文件: %d 个  总计: ¥%.2f\n" "$dir_count" "$dir_total"
        echo

        # 累计全局统计
        TOTAL=$(awk -v sum="$TOTAL" -v dsum="$dir_total" 'BEGIN {printf "%.2f", sum + dsum}')
        COUNT=$((COUNT + dir_count))
    else
        echo "⚠️  未找到发票文件"
        echo
    fi
}

main() {
    TOTAL=0
    COUNT=0

    if [[ $# -eq 0 ]]; then
        process_dir "."
    else
        for dir in "$@"; do
            [[ -d "$dir" ]] && process_dir "$dir"
        done
    fi

    echo "🎯 总计：$COUNT 个文件，¥$TOTAL"
}

main "$@"

