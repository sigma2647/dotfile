#!/usr/bin/env bash

# 检查参数
if [ $# -eq 0 ]; then
    echo "用法: $0 <文件夹路径或PDF文件> [选项]"
    echo "示例: $0 ./2025T-43"
    echo "单个文件: $0 ./new/EDC/电子发票.pdf"
    echo "递归模式: $0 ./new -r 或 $0 ./new --recursive"
    echo "调试模式: $0 ./2025T-43 debug"
    echo "递归+调试: $0 ./new -r debug"
    exit 1
fi

FOLDER_PATH="$1"
RECURSIVE_MODE=""
DEBUG_MODE=""

# 解析参数
shift
while [ $# -gt 0 ]; do
    case "$1" in
        -r|--recursive)
            RECURSIVE_MODE="true"
            ;;
        debug)
            DEBUG_MODE="debug"
            ;;
        *)
            # 兼容旧版本，第二个参数如果是debug就设为调试模式
            if [ "$1" = "debug" ]; then
                DEBUG_MODE="debug"
            fi
            ;;
    esac
    shift
done

# 检查输入路径是否存在
if [ ! -e "$FOLDER_PATH" ]; then
    echo "错误: 路径 '$FOLDER_PATH' 不存在"
    exit 1
fi

# 判断输入是文件还是文件夹
SINGLE_FILE_MODE=""
if [ -f "$FOLDER_PATH" ]; then
    # 检查是否是PDF文件
    if [[ "$FOLDER_PATH" != *.pdf ]]; then
        echo "错误: '$FOLDER_PATH' 不是PDF文件"
        exit 1
    fi
    SINGLE_FILE_MODE="true"
elif [ ! -d "$FOLDER_PATH" ]; then
    echo "错误: '$FOLDER_PATH' 既不是文件也不是文件夹"
    exit 1
fi

# 检查是否安装了pdftotext
if ! command -v pdftotext &> /dev/null; then
    echo "错误: pdftotext 未安装，请先安装 poppler-utils"
    exit 1
fi

# 计算字符串显示宽度的函数（考虑中文字符占2个宽度）
get_display_width() {
    local str="$1"
    local width=0
    local i=0

    while [ $i -lt ${#str} ]; do
        local char="${str:$i:1}"
        local byte_val=$(printf "%d" "'$char" 2>/dev/null || echo 0)

        # 中文字符通常在UTF-8中以高字节开始，这里用简单方法判断
        if [ $byte_val -gt 127 ] 2>/dev/null; then
            width=$((width + 2))
        else
            width=$((width + 1))
        fi
        i=$((i + 1))
    done

    echo $width
}

# 生成分隔线的函数
generate_separator() {
    local target_width=40
    local left_line=$(printf '─%.0s' $(seq 1 $((target_width + 1))))
    local right_line=$(printf '─%.0s' $(seq 1 10))
    echo "$left_line┼$right_line"
}

# 截断文件名的函数
truncate_filename() {
    local filename="$1"
    local max_width=37  # 预留3个字符给省略号

    local display_width=$(get_display_width "$filename")

    if [ $display_width -le 40 ]; then
        echo "$filename"
        return
    fi

    # 需要截断
    local truncated=""
    local current_width=0
    local i=0

    while [ $i -lt ${#filename} ] && [ $current_width -lt $max_width ]; do
        local char="${filename:$i:1}"
        local byte_val=$(printf "%d" "'$char" 2>/dev/null || echo 0)

        # 计算字符宽度
        local char_width=1
        if [ $byte_val -gt 127 ] 2>/dev/null; then
            char_width=2
        fi

        # 检查是否还能添加这个字符
        if [ $((current_width + char_width)) -le $max_width ]; then
            truncated="$truncated$char"
            current_width=$((current_width + char_width))
        else
            break
        fi
        i=$((i + 1))
    done

    echo "$truncated..."
}

# 格式化输出函数，确保表格对齐
format_output() {
    local filename="$1"
    local amount="$2"
    local target_width=40

    # 截断过长的文件名
    filename=$(truncate_filename "$filename")

    local display_width=$(get_display_width "$filename")
    local padding=$((target_width - display_width))

    # 确保padding不为负数
    if [ $padding -lt 0 ]; then
        padding=0
    fi

    # 构造空格字符串
    local spaces=""
    for ((i=0; i<padding; i++)); do
        spaces="$spaces "
    done

    echo "$filename$spaces │ $amount"
}

# 处理单个PDF文件的函数
process_pdf() {
    local pdf_file="$1"
    local relative_path="$2"

    # 获取文件名（不含路径）
    local filename=$(basename "$pdf_file")

    # 如果是递归模式，显示相对路径
    if [ "$RECURSIVE_MODE" = "true" ] && [ -n "$relative_path" ]; then
        filename="$relative_path/$filename"
    fi

    # 提取PDF文本内容
    local text_content=$(pdftotext "$pdf_file" - 2>/dev/null)

    if [ $? -ne 0 ]; then
        format_output "$filename" "提取失败"
        return
    fi

    # 提取金额的多种模式
    local amount=""

    # 模式1: 票价:￥数字格式（火车票）
    local ticket_price=$(echo "$text_content" | grep -oE "票价:￥[0-9]+\.?[0-9]*" | head -1 | sed 's/票价:￥//')

    # 模式2: （小写）¥数字格式（最准确的价税合计）
    local xiaoxie_amount=$(echo "$text_content" | grep -oE "（小写）[[:space:]]*¥[[:space:]]*[0-9]+\.?[0-9]*" | head -1 | sed 's/（小写）[[:space:]]*¥[[:space:]]*//')
    if [ -z "$xiaoxie_amount" ]; then
        xiaoxie_amount=$(echo "$text_content" | grep -oE "（[[:space:]]*小[[:space:]]*写[[:space:]]*）[[:space:]]*¥[[:space:]]*[0-9]+\.?[0-9]*" | head -1 | sed 's/（[[:space:]]*小[[:space:]]*写[[:space:]]*）[[:space:]]*¥[[:space:]]*//')
    fi
    # 处理英文括号的情况
    if [ -z "$xiaoxie_amount" ]; then
        xiaoxie_amount=$(echo "$text_content" | grep -oE "\(小写\)[[:space:]]*¥[[:space:]]*[0-9]+\.?[0-9]*" | head -1 | sed 's/(小写)[[:space:]]*¥[[:space:]]*//')
    fi

    # 模式3: 从文件名中提取数字（备用方案）
    local filename_amount=$(echo "$(basename "$pdf_file")" | grep -oE "_[0-9]+\.?[0-9]*_" | head -1 | sed 's/_//g')

    # 调试模式输出
    if [ "$DEBUG_MODE" = "debug" ]; then
        echo ""
        echo "=== 调试信息: $filename ==="
        echo "完整路径: $pdf_file"
        echo "票价提取: '$ticket_price'"
        echo "小写金额提取: '$xiaoxie_amount'"
        echo "文件名金额提取: '$filename_amount'"
        echo "PDF文本内容（前10行）:"
        echo "$text_content" | head -10
        echo "=========================="
    fi

    # 优先级：票价（火车票） > （小写）金额 > 文件名中的数字
    if [ -n "$ticket_price" ]; then
        amount="¥$ticket_price"
    elif [ -n "$xiaoxie_amount" ]; then
        amount="¥$xiaoxie_amount"
    elif [ -n "$filename_amount" ]; then
        amount="¥$filename_amount"
    else
        amount="未找到金额"
    fi

    format_output "$filename" "$amount"

    # 返回金额用于总计计算
    if [ -n "$ticket_price" ]; then
        echo "$ticket_price" >> /tmp/amounts_$$
    elif [ -n "$xiaoxie_amount" ]; then
        echo "$xiaoxie_amount" >> /tmp/amounts_$$
    elif [ -n "$filename_amount" ]; then
        echo "$filename_amount" >> /tmp/amounts_$$
    fi
}

echo "发票金额提取结果"
# echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
format_output "文件名" "金额"
generate_separator

# 创建临时文件用于存储金额
> /tmp/amounts_$$

# 根据输入类型选择不同的处理方式
if [ "$SINGLE_FILE_MODE" = "true" ]; then
    # 单个PDF文件模式
    process_pdf "$FOLDER_PATH" ""
elif [ "$RECURSIVE_MODE" = "true" ]; then
    # 递归模式：使用find命令查找所有PDF文件
    find "$FOLDER_PATH" -name "*.pdf" -type f | while read -r pdf_file; do
        # 计算相对路径
        relative_path=$(dirname "${pdf_file#$FOLDER_PATH/}")
        if [ "$relative_path" = "." ]; then
            relative_path=""
        fi
        process_pdf "$pdf_file" "$relative_path"
    done
else
    # 非递归模式：只处理当前文件夹的PDF文件
    found_pdf=false
    for pdf_file in "$FOLDER_PATH"/*.pdf; do
        if [ -f "$pdf_file" ]; then
            found_pdf=true
            process_pdf "$pdf_file" ""
        fi
    done

    if [ "$found_pdf" = false ]; then
        echo "警告: 文件夹中没有找到PDF文件"
    fi
fi

generate_separator

# 计算总金额（如果不是调试模式）
if [ "$DEBUG_MODE" != "debug" ]; then
    if [ -f "/tmp/amounts_$$" ]; then
        total=0
        count=0
        while read -r amount; do
            if [ -n "$amount" ]; then
                total=$(echo "$total + $amount" | bc -l 2>/dev/null || echo "$total")
                count=$((count + 1))
            fi
        done < /tmp/amounts_$$

        if command -v bc &> /dev/null && [ "$count" -gt 0 ]; then
            # echo "----------------------------------------│----------"
            format_output "总计 ($count 个文件)" $(printf "¥%.2f" "$total")
        fi

        # 清理临时文件
        rm -f /tmp/amounts_$$
    fi
fi
echo "提取完成！"
